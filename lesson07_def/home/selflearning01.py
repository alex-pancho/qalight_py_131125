# selflearning_tasks.py

# Інструкція:
# 1. Уважно прочитайте коментарі до кожного завдання.
# 2. Напишіть код для виконання кожного завдання у відведеному місці.
# 3. Не змінюйте імена функцій, які ви маєте реалізувати.
# 4. Після завершення запустіть файл test_selflearning.py для перевірки вашої роботи.

# -------------------------------------------------------------------------------------
# Завдання 1: Робота з вбудованими функціями
# Мета: Закріпити навички використання функцій `sum()`, `max()`, `min()`, `len()`.
#
# Створіть функцію `analyze_list(numbers)`, яка приймає список чисел.
# Функція повинна повернути словник, що містить:
# - 'sum': суму всіх чисел у списку.
# - 'max': максимальне число у списку.
# - 'min': мінімальне число у списку.
# - 'len': кількість елементів у списку.
#
# Примітка: для порожнього списку `max()` та `min()` можуть викликати помилку.
# Опрацюйте цей випадок, щоб функція повертала None для max та min, якщо список порожній.
#
# Приклад: analyze_list([1, 2, 3, 4, 5]) повинна повернути {'sum': 15, 'max': 5, 'min': 1, 'len': 5}
print("\nTask_1")
def analyze_list(numbers):
    if not numbers:
        return {'sum': 0, 'max': None, 'min': None, 'len': 0}
    return {'sum': sum(numbers), 'max': max(numbers),  # Ваш код тут
            'min': min(numbers), 'len': len(numbers)}
print(analyze_list([1, 2, 3, 4, 5]))

# -------------------------------------------------------------------------------------
# Завдання 2: Різниця між `sorted()` та `sort()`
# Мета: Зрозуміти різницю між функцією `sorted()` та методом `.sort()`.
#
# Створіть функцію `get_sorted_list(numbers)`, яка приймає список чисел.
# Функція повинна повернути НОВИЙ відсортований список у порядку зростання.
# ВАЖЛИВО: оригінальний список, переданий у функцію, не повинен змінюватися.
#
# Приклад:
# original_list = [5, 2, 8, 1]
# sorted_list = get_sorted_list(original_list)
# print(sorted_list)  # повинно вивести [1, 2, 5, 8]
# print(original_list) # повинно вивести [5, 2, 8, 1]
print("\nTask_2")
def get_sorted_list(numbers):
    # Ваш код тут
    return sorted(numbers)
original_list = [5, 2, 8, 1]
sorted_list = get_sorted_list(original_list)
print(sorted_list)
print(original_list)

# -------------------------------------------------------------------------------------
# Завдання 3: Створення функції з аргументами за замовчуванням
# Мета: Навчитися створювати функції з позиційними та іменованими аргументами,
# а також використовувати значення за замовчуванням.
#
# Створіть функцію `greet(name, greeting="Привіт")`.
# Функція повинна повертати рядок привітання у форматі: "{greeting}, {name}!".
#
# Приклад:
# greet("Іван") повинна повернути "Привіт, Іван!"
# greet("Олена", "Доброго дня") повинна повернути "Доброго дня, Олена!"
print("\nTask_3")
def greet(name, greeting="Привіт"):
    # Ваш код тут
    return f"{greeting}, {name}!"
print(greet("Іван"))
print(greet("Олена", "Доброго дня"))
# -------------------------------------------------------------------------------------
# Завдання 4: Використання `*args`
# Мета: Навчитися створювати функції, що приймають довільну кількість позиційних аргументів.
#
# Створіть функцію join_with_me(*args, separator=":"), яка:
# Приймає будь-яку кількість позиційних аргументів *args.
# Об’єднує їх у один рядок, розділяючи значення вказаним роздільником separator.
# За замовчуванням використовується роздільник ":".
#
# Приклад:
# join_with_me(1, 2, 3) повинна повернути "1:2:3"
# join_with_me(1, 2, 3, separator="," ) повинна повернути "1,2,3"
print("\nTask_4")
def join_with_me(*args, separator=":"):
    # код
    return separator.join(map(str, args))
print(join_with_me(1, 2, 3))
print(join_with_me(1, 2, 3, separator=","))

# -------------------------------------------------------------------------------------
# Завдання 5: Використання `**kwargs`
# Мета: Навчитися створювати функції, що приймають довільну кількість іменованих аргументів.
#
# Приймати довільну кількість іменованих аргументів (**kwargs).
# Шукати у них два параметри:
# prefix — текст перед значенням (за замовчуванням "Value"),
# suffix — текст після значення (за замовчуванням "").
# Повернути один рядок, де кожна пара ключ–значення буде у форматі:
# <prefix> key = value <suffix>
# Елементи потрібно розділяти через "; "
# format_options(a=1, b=2, prefix="[", suffix="]")
# "[ a = 1 ] ; [ b = 2 ]"
print("\nTask_5")
def format_options(**kwargs):
    # Ваш код тут
    prefix = kwargs.pop("prefix", "Value")
    suffix = kwargs.pop("suffix", "")
    separator = kwargs.pop("separator", " ; ")
    outlist = []
    for key, value in kwargs.items():
        outstring = f" {prefix} {key} = {value} {suffix}"
        outlist.append(outstring)
    return separator.join(outlist)
print(format_options(a=1, b=2, prefix="[", suffix="]"))

# -------------------------------------------------------------------------------------
# Завдання 6: Комбінація позиційних та ключових аргументів
# Мета: Навчитися комбінувати різні типи аргументів у одній функції.
#
# Створіть функцію `format_data(main_title, *items, **options)`.
# - `main_title`: обов'язковий позиційний аргумент (рядок).
# - `*items`: довільна кількість позиційних аргументів (рядків).
# - `**options`: довільна кількість іменованих аргументів. Функція повинна шукати
#   опцію `separator` (за замовчуванням ', ') та `prefix` (за замовчуванням 'Item').
#
# Функція повинна повернути один рядок, що починається з `main_title`,
# за яким іде двокрапка, а потім перелік `items`, де кожен елемент має `prefix` і
# вони розділені `separator`.
#
# Приклад:
# format_data("Products", "Apple", "Banana", separator=" | ", prefix="Fruit")
# повинна повернути: "Products: Fruit: Apple | Fruit: Banana"
#
# format_data("Cities", "Kyiv", "Lviv")
# повинна повернути: "Cities: Item: Kyiv, Item: Lviv"
# ПОРАДА-ПІДКАЗКА: можливо допоможе використання функцій з завдань 4 та 5
print("\nTask_6")
def format_data(main_title, *items, **kwargs):
    # Ваш код тут
    prefix = kwargs.pop("prefix", "item")
    suffix = kwargs.pop("suffix", "")
    separator = kwargs.pop("separator", ", ")
    outlist = []
    for item in items:
        outstring = f"{prefix}: {item}"
        outlist.append(outstring)
    return f"{main_title}: " + separator.join(outlist)
out = format_data("Products", "Apple", "Banana", separator=" | ", prefix="Fruit")
print(out)
out_2 = format_data("Cities", "Kyiv", "Lviv")
print(out_2)

# -------------------------------------------------------------------------------------
# Завдання 7: Лямбда-функції
# Мета: Зрозуміти синтаксис та використання лямбда-функцій.
#
# Створіть змінну `is_even`, якій присвоєно лямбда-функцію.
# Ця лямбда-функція повинна приймати одне число і повертати `True`, якщо воно парне,
# і `False` в іншому випадку.
#
# Приклад:
# is_even(2) повинно повернути True
# is_even(3) повинно повернути False
print("\nTask_7")
is_even = lambda x: x % 2 == 0  # Ваш код тут, замініть None на лямбда-функцію

print(is_even(2))
print(is_even(3))
print(is_even(10))
print(is_even(15))

# -------------------------------------------------------------------------------------
# Завдання 8: Використання `filter` з лямбда-функцією
# Мета: Навчитися використовувати `filter` для фільтрації даних.
#
# Створіть функцію `filter_positive_numbers(numbers)`, яка приймає список чисел
# і повертає список, що містить тільки додатні числа (число 0 не є додатнім).
# Використайте для цього функцію `filter` та лямбда-функцію.
#
# Приклад:
# filter_positive_numbers([-1, 2, -3, 4, 0, 5]) повинна повернути [2, 4, 5]
print("\nTask_8")
def filter_positive_numbers(numbers):
    # Ваш код тут
    return list(filter(lambda x: x > 0, numbers))
print(filter_positive_numbers([-1, 2, -3, 4, 0, 5]))

